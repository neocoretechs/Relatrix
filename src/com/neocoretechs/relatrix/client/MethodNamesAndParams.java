package com.neocoretechs.relatrix.client;

import java.io.Serializable;
import java.util.Vector;

import com.neocoretechs.relatrix.server.GenerateClientBindings;
import com.neocoretechs.relatrix.server.ServerInvokeMethod;
/**
* A basic Serializable helper class used with {@link ServerInvokeMethod} with arrays of Method names and 
* parameters for a target class to be passed to a remote "handler" class whose transport layer can be generated by hand or
* via {@link GenerateClientBindings}. There are typically one of these instances per target class.
* An instance of this may be passed to client or server on RemoteObject creation.  This will contain the
* methods to be advertised to the rest of the world.  A call
* from remote client may verify the method before remote call using an instance of this.<p/>
* An index into any of the arrays and/or collections will point to the corresponding elements in the other structures
* for that particular method of the target class.
* @author Jonathan Groff Copyright (C) NeoCoreTechs, Inc. 1998-2000,2015
*/
public final class MethodNamesAndParams implements Serializable {
       static final long serialVersionUID = 8837760295724028863L;
       public transient Class<?> classClass;
       public String className;
       public transient Vector<String> methodNames = new Vector<String>();
       public transient Class<?>[][] methodParams;
       public String[] methodSigs;
       public transient Class<?>[] returnTypes;

       /**
       * No arg ctor call for deserialized
       */
       public MethodNamesAndParams() {}

       public String[] getMethodSigs() { return methodSigs; }

       public Class<?>[] getReturnTypes() { return returnTypes; }

       public Vector<String> getMethodNames() { return methodNames; }
       /**
        * Search for the method name combined with as much of the fully qualified param signature as is required to
        * uniquely identify the method, such that if overloaded methods exist, they can be uniquely identified. SO,
        * last(java.lang.String) and last() would require name=last, methodSig="" or methodSig="java.lang.String" or just
        * methodSig="j" to locate overloaded method.
        * @param name method name full
        * @param methodSig parameter list partial with fully qualified class names
        * @return index of method in corresponding methodSigs and returnTypes arrays or -1 if name/sig cannot be found
        */
       public int getMethodIndex(String name, String methodSig) {
    	  int iname = methodNames.indexOf(name);
    	  while(iname != -1) {
    	 	  if(methodSigs[iname].contains(name+"("+methodSig))
        		  break;
    		  iname = methodNames.indexOf(name,iname);
    	  }
    	  return iname;
       }

}
